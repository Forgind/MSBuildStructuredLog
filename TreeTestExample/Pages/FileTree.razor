@*Creates the layout of the File Tree Panel in the center*@

@page "/FileTree"
@using System.IO
@using System.Collections
@using Microsoft.Build.Logging.StructuredLogger
@using Radzen
@using Radzen.Blazor
@inject Blazor.FileReader.IFileReaderService fileReaderService
@inject NotificationService notificationService

<center>
    <h1>Structured Log Viewer</h1>
    <input type="file" @ref=fileToRead />
    <button @onclick=ReadFile class="btn btn-primary">Read file</button>
    <button @onclick=ClearFile class="btn btn-primary">Clear</button>
    <br />
    <br />

    @if (reading)
    {
<RadzenProgressBar Value="@_progressValue" 
                   ShowValue="false" 
                   Mode="ProgressBarMode.Determinate" 
                   Style="margin-bottom: 20px" />
        <h3>@waitText</h3>
    }
</center>


<br />
<br />
@if (binLogSelected)
{
<div id="fileTree">
    <RadzenTree Data="@fileTree" 
                Style="word-break:break-all;overflow-y:scroll"
                Expand="@((TreeExpandEventArgs args) => {TreeFormatting.OnExpandFiles(args);})"
                Change="@OnChange">
        <RadzenTreeLevel Template="@TreeFormatting.TreeDesignFiles"
                         Text="@TreeFormatting.TextSelector"
                         Selected="@((node) => {
                                         bool temp = ((BaseNode)node).SourceDisplayed;
                                         ((BaseNode)node).SourceDisplayed = false;
                                         return temp; })"
                         Expanded="@((node) => { return ((BaseNode)node).IsExpanded; })"
                         HasChildren="@((node) => {
                                    if (node is TreeNode)
                                        return ((TreeNode)node).HasChildren;
                                    else return false;
                                })" />
    </RadzenTree>
</div>
}
<RadzenNotification />

@code {
    [CascadingParameter]
    public SplitPane ContainerSplit { get; set; }
    static bool binLogSelected = false;
    static ElementReference fileToRead;
    static bool reading;
    static string waitText;
    double _progressValue = 0;
    static IEnumerable<BaseNode> fileTree = null;

    /// <summary>
    /// Fired when a user selects a tree node from the results
    /// Opens the file and highlights the line where the info can be found
    /// </summary>
    /// <param name="args"> Handler that holds the event (.Value is the tree node selected) </param>
    void OnChange(TreeEventArgs args)
    {
        SourceFileHelper.SourceFileText(ContainerSplit, ContainerSplit.sourceFileResolver, (BaseNode)args.Value);
        if (!ContainerSplit.showSourceFilePanel)
        {
            ContainerSplit.showSourceFilePanel = true;
            ContainerSplit.Render();
        }
        ContainerSplit.SourceFileRender();
    }

    /// <summary>
    /// Fired when a user selects a file to read that is not a .binlog
    /// Shows an error message explaining that only .binlog files can be read
    /// </summary>
    /// <param name="message"> Message to be displayed to the user </param>
    /// <returns></returns>
    async System.Threading.Tasks.Task ShowNotification(NotificationMessage message)
    {
        message.Severity = NotificationSeverity.Error;
        message.Summary = "Wrong File Type!";
        message.Detail = "Currently we only read .binlog files. Click Instructions to learn more.";
        message.Duration = 4000;
        notificationService.Notify(message);
    }

    /// <summary>
    /// Fired when user selects the Clear button
    /// Resets the app to original state before reading file
    /// </summary>
    /// <returns> Task to update app</returns>
    public async System.Threading.Tasks.Task ClearFile()
    {
        await fileReaderService.CreateReference(fileToRead).ClearValue();
        binLogSelected = false;
        reading = false;
        waitText = "";
        fileTree = null;
        ContainerSplit.projectFiles = null;
        FindInFiles.findResults = null;
        SearchViewer.searchResults = null;
        ContainerSplit.searching = true;
        if (ContainerSplit.showSourceFilePanel)
        {
            ContainerSplit.showSourceFilePanel = false;
            ContainerSplit.searching = false;
        }
        ContainerSplit.Render();
        FindInFiles.searchKeyword = null;
        SearchViewer.searchKeyword = null;
    }

    /// <summary>
    /// Fired when user selects Read File button
    /// Reads the file: produces file tree and File tab if .binlog otherwise shows error
    /// </summary>
    /// <returns> Task to update app</returns>
    public async System.Threading.Tasks.Task ReadFile()
    {
        try {
            //setting appropriate variables to display progress bar
            binLogSelected = false;
            reading = true;
            this.StateHasChanged();
            waitText = "Here we go...";

            //creating files list from the file selected
            var files = (await fileReaderService.CreateReference(fileToRead).EnumerateFilesAsync());
            foreach (Blazor.FileReader.IFileReference file in files)
            {
                //determining if file is of type .binlog (errors if not)
                var fileInfo = await file.ReadFileInfoAsync();
                String[] split = fileInfo.Name.Split(".");
                if (!String.Equals("binlog", split[split.Length - 1]))
                {
                    await ShowNotification(new NotificationMessage());
                    await ClearFile();
                    return;
                }
                waitText = "Still reading...";
                this.StateHasChanged();
                binLogSelected = true;

                //reading .binlog file using streams (must be put into memoryStream to properly read
                Task<Blazor.FileReader.AsyncDisposableStream>
                streamTask = file.OpenReadAsync();
                var stream = await streamTask;
                var memoryStream = new MemoryStream();
                waitText = "Teaching you patience...";
                this.StateHasChanged();
                await stream.CopyToAsync(memoryStream);
                memoryStream.Position = 0;
                System.Diagnostics.Stopwatch timeSinceUpdate = System.Diagnostics.Stopwatch.StartNew();

                //reading build and creating tree from the build
                ContainerSplit.build = await BinaryLog.ReadBuild(memoryStream, progressFunc: async (current, total) =>
                {
                    if (timeSinceUpdate.Elapsed.TotalSeconds > 0.1)
                    {
                        //waitText = current.ToString() + " / " + total.ToString();
                        //Console.WriteLine(waitText);
                        _progressValue = 100 * current / (double)total;
                        this.StateHasChanged();
                        await System.Threading.Tasks.Task.Delay(1);
                        timeSinceUpdate.Restart();
                    }
                });
                waitText = "Trust me you're computer wants this to be over more than you do...";
                BuildAnalyzer.AnalyzeBuild(ContainerSplit.build);
                fileTree = (IEnumerable<BaseNode>)ContainerSplit.build.Children;

                //creating a search object to be used in the Search tab
                SearchViewer.searcher = new StructuredLogViewer.Search(ContainerSplit.build, StructuredLogViewer.Search.DefaultMaxResults);
                this.StateHasChanged();
                waitText = "Not a joke...We're actually still reading...";
                this.StateHasChanged();
            }

            //creating file resolvers to read/look through archive/source files
            ContainerSplit.sourceFileResolver = new StructuredLogViewer.SourceFileResolver(ContainerSplit.build.SourceFilesArchive);
            ContainerSplit.archiveFileResolver = ContainerSplit.sourceFileResolver.ArchiveFile;

            //populates the Files tab with the projectFiles tree
            PopulateFilesTab();
            this.StateHasChanged();
            reading = false;
            waitText = "";
        } catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
            throw;
        }

    }

    /// <summary>
    /// Creates the project files tree in the Files tab
    /// </summary>
    public void PopulateFilesTab()
    {
        var root = new Folder();
        StructuredLogViewer.ArchiveFileResolver archiveFile = ContainerSplit.archiveFileResolver;

        foreach (var file in archiveFile.Files.OrderBy(kvp => kvp.Key, StringComparer.OrdinalIgnoreCase))
        {
            var parts = file.Key.Split('\\');
            AddSourceFile(root, file.Key, parts, 0);
        }

        foreach (var subFolder in root.Children.OfType<Folder>())
        {
            CompressTree(subFolder);
        }

        ContainerSplit.projectFiles = (IEnumerable<BaseNode>)root.Children;
        this.StateHasChanged();
    }

    /// <summary>
    /// Creates a tree structure such that if folders have same parent they are displayed under that same node
    /// </summary>
    /// <param name="parent"> parent folder to </param>
    private void CompressTree(Folder parent)
    {
        if (parent.Children.Count == 1 && parent.Children[0] is Folder subfolder)
        {
            parent.Children.Clear();
            var grandchildren = subfolder.Children.ToArray();
            subfolder.Children.Clear();
            foreach (var grandChild in grandchildren)
            {
                parent.Children.Add(grandChild);
            }

            parent.Name = Path.Combine(parent.Name, subfolder.Name);
            CompressTree(parent);
        }
        else
        {
            foreach (var subFolder in parent.Children.OfType<Folder>
                ())
            {
                CompressTree(subFolder);
            }
        }
    }

    /// <summary>
    /// adds a sourcefile as a child to the parent node
    /// </summary>
    /// <param name="folder"> folder to add the child to </param>
    /// <param name="filePath">path of the file the child is located at </param>
    /// <param name="parts"> holds information about the child including the file name </param>
    /// <param name="index"> locates where the file name can be found in the parts array</param>
    private void AddSourceFile(Folder folder, string filePath, string[] parts, int index)
    {
        if (index == parts.Length - 1)
        {
            var file = new Microsoft.Build.Logging.StructuredLogger.SourceFile()
            {
                SourceFilePath = filePath,
                Name = parts[index]
            };
            folder.AddChild(file);
        }
        else
        {
            var subfolder = folder.GetOrCreateNodeWithName<Folder>
                (parts[index]);
            subfolder.IsExpanded = true;
            AddSourceFile(subfolder, filePath, parts, index + 1);
        }
    }
}
